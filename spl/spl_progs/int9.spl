//___________________________________________________***_INT_9_Exec_system_call_***___________________________________________________//

// Arguments: File Name (String) of the executable file

//__________*** Return Value ***__________//
// -1 : File not found or file is not executable
//________________________________________//


//_______ SPL Variables ______//
alias userSP R0;
alias fileName R1;
alias iter R6;
alias temp R3;
alias inode_index R4;
alias codeSize R5;
//____________________________//



// Set mode flag //
[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 9] = INT_EXEC;

// Store SP to a register //
userSP = SP;

// Save user SP to process table //
[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 13] = userSP;

// Switch to kernel stack //
SP = [PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 11] * 512 - 1;

// Extract file name //
fileName = [([PTBR + 2 * ((userSP - 4) / 512)] * 512)  + ((userSP - 4) % 512)];

iter = 0;

while (iter < MAX_FILE_NUM) do
    temp = [INODE_TABLE + 16*iter + 1];
    if (fileName == temp) then
        if ([INODE_TABLE + 16*iter + 0] == EXEC) then
            inode_index = iter;
            break;
        endif;
    endif;
    iter = iter+1;
endwhile;


if (iter == MAX_FILE_NUM) then

    // Return -1 for failure to find valid file
    temp = ([PTBR + 2 * ((userSP - 1) / 512)] * 512) + ((userSP - 1) % 512);
	[temp] = -1;

    // Switch back to user stack //
    SP = userSP;

    // Reset mode flag //
    [PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 9] = 0;

    // Return to user program
    ireturn;
endif;

// If all is well call exit process function in process manager module
multipush(R0,R1,R2,R3,R4,R6);

R1 = EXIT_PROCESS;
R2 = [SYSTEM_STATUS_TABLE + 1];
call PROCESS_MANAGER;

multipop(R0,R1,R2,R3,R4,R6);


// Reclaim user area page

// temp holds memory free list entry
temp = MEMORY_FREE_LIST + [PROCESS_TABLE + 16*[SYSTEM_STATUS_TABLE + 1] + 11];
// Increment memory free list entry
[temp] = [temp]+1;

// decrement MEM_FREE_COUNT
[SYSTEM_STATUS_TABLE + 2] = [SYSTEM_STATUS_TABLE + 2] - 1;

// Set SP for new process
SP = [PROCESS_TABLE + 16*[SYSTEM_STATUS_TABLE + 1] + 11]*512 - 1;

// Set state of process
[PROCESS_TABLE + 16*[SYSTEM_STATUS_TABLE + 1] + 4] = RUNNING;

// Set inode index of process
[PROCESS_TABLE + 16*[SYSTEM_STATUS_TABLE + 1] + 7] = inode_index;

//--------------------------------------------------------------------------------------------------------//
// Page table setup
PTBR = PAGE_TABLE_BASE + [SYSTEM_STATUS_TABLE + 1] * 20;
PTLR = 10;

//Library
[PTBR+0] = 63;
[PTBR+1] = "0100";
[PTBR+2] = 64;
[PTBR+3] = "0100";


// Invoke the Get Free Page function to allocate 2 stack pages.

multipush(R0,R1,R2,R3,R4,R6);

// Invalidate Heap entries
[PTBR+4] = -1;
[PTBR+5] = "0000";
[PTBR+6] = -1;
[PTBR+7] = "0000";

// Stack
R1 = GET_FREE_PAGE;
//  //  //  //  //  //
call MEMORY_MANAGER;
//  //  //  //  //  //
[PTBR+16] = R0;
[PTBR+17] = "0110";

R1 = GET_FREE_PAGE;
//  //  //  //  //  //
call MEMORY_MANAGER;
//  //  //  //  //  //
[PTBR+18] = R0;
[PTBR+19] = "0110";

multipop(R0,R1,R2,R3,R4,R6);

// Find out the number of blocks occupied by the file from inode table
codeSize = ([INODE_TABLE + 16 * inode_index + 2] + 511) / 512;

// Allocate the first code page only
multipush(R0,R1,R2,R3,R4,R5,R6);

R1 = GET_CODE_PAGE;
R2 = [INODE_TABLE + 16 * inode_index + 8];
//  //  //  //  //  //
call MEMORY_MANAGER;
//  //  //  //  //  //

[PTBR + 8] = R0;
[PTBR + 8 + 1] = "0100";

multipop(R0,R1,R2,R3,R4,R5,R6);

// Invalidate rest of the code blocks
iter = 1;
while (iter < 4) do
    [PTBR + 8 + iter * 2] = -1;
    [PTBR + 8 + iter * 2 + 1] = "0000";
    iter = iter + 1;
endwhile;
//--------------------------------------------------------------------------------------------------------//


//--------------------------------------------------------------------------------------------------------//
// Initialize the per-process disk map table (just fill up for the code blocks)
iter = 0;
while (iter < 10) do
    [DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE + 1]*10 + iter] = -1; 
    iter = iter+1;
endwhile;
[DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE + 1]*10 + 4] = [INODE_TABLE + 16 * inode_index + 8];
[DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE + 1]*10 + 5] = [INODE_TABLE + 16 * inode_index + 9];
[DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE + 1]*10 + 6] = [INODE_TABLE + 16 * inode_index + 10];
[DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE + 1]*10 + 7] = [INODE_TABLE + 16 * inode_index + 11];
//--------------------------------------------------------------------------------------------------------//

// per-process resource table should be initialized in this user area page. Since the 
// newly created process has not opened any files or semaphores, each entry in the 
// per-process table is initialized to -1.
R9 = [PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 11];
iter = R9 * 512 + 512 - 16;
while (iter < (R9 * 512 + 512)) do
    [iter] = -1;
    iter = iter + 1;
endwhile;

//Storing the IP in the top of the user stack and setting SP in logical address
[[PTBR+16] * 512] = [[PTBR + 8] * 512 + 1];

SP = 8 * 512;

// Reset mode flag
[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 9] = 0;


ireturn;